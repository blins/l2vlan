# Драйвер для подключения контейнеров во внешний vlan по L2

## Предистория

Понадобилось мне запустить несколько контейнеров в docker swarm и выпустить их траффик непосредственно в определенный vlan. 
Всё было готово с точки зрения классической организации сети: vlan создан на маршрутизаторе, навешан gateway 
и дотянут на коммутаторах до порта на серверах. Каждый контейнер должен иметь свой фиксированный адрес.
Я недолго думая создал сети macvlan на всех узлах и запустил один контейнер.
Всё было хорошо. Я запустил второй контейнер. И тут всё было хорошо. Только вот третий контейнер не хотел запускаться...

Давай я копать, что же могло пойти не так. Контейнер не запускался с ошибкой (прим. перевод): "Шлюз (айпишник) не может 
быть назначен из-за того, что он уже назначен где-то". 

Фигассе, - думаю. Этого адреса нигде нету, пробежался по все интерфейсам - нету, от слова "совсем". Замечаю, что это 
не работает на узле где уже запущен этот контейнер или, внезапно, была попытка запуска контейнера. Я в абсолютных непонятках
остановил запущенные контейнеры, которые привязаны к этим сетям и давай удалять сети. Сама сеть удалилась, а вот конфиги 
сетей не хотят удаляться, говорят, что они где-то используются. Всё проверил, не нашел использования. Пошукал в ихних интернетах:
пришут что это есть такая бага и надо бы стопануть сервис докера и удалить локальное хранилище... и тогда у тебя пропадут 
все локальные конфиги и будет тебе счастье... Хорошо, что у меня из локальных конфигов были пока только эти.

Ладно, вышарашил и стал думу думать. Сделал стенд у себя на локальном компьютере и воспроизвел ошибку.

Воспроизводится она, кстати, очень легко:

```bash
$ docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 --ip-range=192.168.1.2/32 \
    --config-only -o parent=eno1.2000 net1conf
$ docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 --ip-range=192.168.1.3/32 \
    --config-only -o parent=eno1.2000 net2conf
$ docker network create -d macvlan --scope swarm --config-from net1conf net1 
$ docker network create -d macvlan --scope swarm --config-from net2conf net2
$ docker stack deploy -c docker-compose1.yml stack1
# здесь еще всё хорошо
$ docker stack deploy -c docker-compose2.yml stack2
# а вот это уже было ошибкой 
```

Стеки очень простые: состоят из одного сервиса nginx, который в одном экземпляре запускается и подключается во внешнюю 
сеть net1 и net2 соответственно.

Для примера приведу один файлик:
```yaml
version: "3.7"

services:
  nginx:
    image: nginx:alpine
    networks:
      - net1
    deploy:
      restart_policy:
        condition: any
      mode: replicated
      replicas: 1

networks:
  net1:
    external: true
```

Скачал себе исходный код moby и libnetwork и стал искать что генерирует такую ошибку. Оказалось драйвер IPAM. Такое поведение 
можно исправить, если написать свой драйвер и использовать его. "Ну ок". Сказано - сделано.

Написал драйвер, где поведение от стандартного отличается только тем, что он не ругается на адрес gateway совсем, 
он просто принимает его к сведению.

И вот я полный предвкушения и триумфа запускаю всё по выше приведенному примеру и получаю жесткий облом. При создании net2
драйвер macvlan не может создать интерфейс eno1.2000. Фигня вопрос - используем драйвер bridge. А вот тут всё хорошо, 
но только этот драйвер за каким-то хреном навешивал адрес шлюза на используемый bridge. И никак его было не переубедить.

Вобщем пришел к выводу что надо написать свой сетевой драйвер. И вот он.

## Как это работает   

Драйвер создает bridge с указанным именем. Создает sub-interface с указанным тегом vlan к указанному interface.  
Объединяет созданное.
А дальше просто подсоединяет по L2 контенеры к этому bridge.

Если bridge уже создан, то драйвер не проверяет наличие sub-interface с указанным тегом vlan? т.к. предполагается что он 
уже создан и работает.

Странно почему господа программисты из компании docker не додумались до такого. наверняка ведь было бы востребовано.

## Как пользоваться 

Сначала нужно установить плагин:
```bash
$ docker plugin install --alias "l2vlan" blins1999/l2vlan
```

Создавать сеть примерно так:
```bash
$ docker network create -d l2vlan:latest --ipam-driver l2vlan:latest --subnet=192.168.1.0/24 --gateway=192.168.1.1 \
    --ip-range=192.168.1.4/32 -o vlan_id=2000 -o ext_if=eno1 -o bridge_name=vlan2000 --config-only net1conf
$ docker network create -d l2vlan:latest --ipam-driver l2vlan:latest --scope swarm --config-from net1conf net1
```

Надо ли говорить, что первая команда выполняется на КАЖДОМ узле кластера.

Дальше можно добавлять статические адреса:
```bash
$ docker network create -d l2vlan:latest --ipam-driver l2vlan:latest --subnet=192.168.1.0/24 --gateway=192.168.1.1 \
    --ip-range=192.168.1.6/32 -o vlan_id=2000 -o ext_if=eno1 -o bridge_name=vlan2000 --config-only net2conf
$ docker network create -d l2vlan:latest --ipam-driver l2vlan:latest --scope swarm --config-from net2conf net2
```

И всё это будет подключено к одному и тому же brdige (в рамках одного узка конечно)

## Что надо бы сделать

 - Надо разобраться с linux сapabilities. Буду рад помощи. 
 

Ну и вроде всё :)